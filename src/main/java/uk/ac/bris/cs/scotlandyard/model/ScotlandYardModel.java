package uk.ac.bris.cs.scotlandyard.model;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import uk.ac.bris.cs.gamekit.graph.Graph;

import static java.util.Arrays.asList;
import static java.util.Collections.emptySet;
import static java.util.Collections.singletonList;
import static java.util.Collections.unmodifiableCollection;
import static java.util.Collections.unmodifiableList;
import static java.util.Collections.unmodifiableSet;
import static java.util.Objects.requireNonNull;
import static uk.ac.bris.cs.scotlandyard.model.Colour.Black;
import static uk.ac.bris.cs.scotlandyard.model.Ticket.Double;
import static uk.ac.bris.cs.scotlandyard.model.Ticket.Secret;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import uk.ac.bris.cs.gamekit.graph.Edge;
import uk.ac.bris.cs.gamekit.graph.Graph;
import uk.ac.bris.cs.gamekit.graph.ImmutableGraph;

//Added to allow use of maps in valid moves
import java.util.HashMap;
import java.util.Map;

public class ScotlandYardModel implements ScotlandYardGame,Consumer<Move> {

	//rounds is a list that contains the rounds that are reveal rounds (where True = reveal)
	private List<Boolean> rounds;
	//graph is a graph that contains all possible connections from one node to another and their relative transport
	private Graph<Integer,Transport> graph;
	//The list of players in the game, Mr X will always be the first player
	private List<ScotlandYardPlayer> players;
	//The current player making a move
	private ScotlandYardPlayer currentPlayer;
	//The set of valid moves generated by validMoves method
	private Set<Move> possibleMoves;
	//A list of spectators that are updated throughout the game
	private List<Spectator> spectators;
	//A refrence to Mr X, allowing the game to easily check win conditions
	private ScotlandYardPlayer mrXPlayer;
	//Mr X's last visible location from the last reveal round
	private int mrXLastLocation;
	//Stores the current round, iterates once Mr X has made a move
	private int currentRound;
	//A variable to store which side has won, either detectives (2) or Mr X (1).
	private int winners;


	//Constructs the game, initializing all variables as long as they are valid
	public ScotlandYardModel(List<Boolean> rounds, Graph<Integer, Transport> graph,
			PlayerConfiguration mrX, PlayerConfiguration firstDetective,
			PlayerConfiguration... restOfTheDetectives) {

		ArrayList<PlayerConfiguration> detectiveArray = new ArrayList<>();
		int numOfDetectives;

		detectiveArray.add(firstDetective);
		numOfDetectives = 1;

		for (PlayerConfiguration detective : restOfTheDetectives){
			detectiveArray.add(detective);
			numOfDetectives = numOfDetectives + 1;
		}

		if (numOfDetectives > 5){
			throw new IllegalArgumentException("Too many detectives");
		}


		graphAndRoundChecks(rounds, graph);
		colourChecks(mrX, detectiveArray);
		locationChecks(mrX, detectiveArray);
		ticketChecks(mrX, detectiveArray);
		players = new ArrayList<ScotlandYardPlayer>();
		makePlayers(mrX, detectiveArray);
		mrXLastLocation = 0;
		currentRound = 0;
		winners = 0;
		spectators = new ArrayList<>();
	}

	//Checks the graph and rounds inputted are valid
	private void graphAndRoundChecks(List<Boolean> rounds, Graph<Integer, Transport> graph){
		this.rounds = requireNonNull(rounds);
		if (rounds.isEmpty()){
			throw new IllegalArgumentException("Empty round list");
		}

		this.graph = requireNonNull(graph);
		if (graph.isEmpty()){
			throw new IllegalArgumentException("Empty graph");
		}
	}

	//Creates new encapsulated player objects and stores them
	private void makePlayers(PlayerConfiguration mrX, ArrayList<PlayerConfiguration> detectiveArray){
		ScotlandYardPlayer storePlayer;
		storePlayer = new ScotlandYardPlayer(mrX.player, mrX.colour, mrX.location, mrX.tickets);
		currentPlayer = storePlayer;
		mrXPlayer = storePlayer;
		this.players.add(storePlayer);
		for (PlayerConfiguration detective : detectiveArray){
			storePlayer = new ScotlandYardPlayer(detective.player, detective.colour, detective.location, detective.tickets);
			this.players.add(storePlayer);
		}
	}

	//Checks all players have a map of all tickets, but Mr X is the only one allowed secret and move tickets
	private void ticketChecks(PlayerConfiguration mrX,ArrayList<PlayerConfiguration> detectiveArray){
		Set<Ticket> detectiveTickets;
		Set<Ticket> ticketSet = new HashSet<>();

		ticketSet.add(Ticket.Taxi);
		ticketSet.add(Ticket.Bus);
		ticketSet.add(Ticket.Double);
		ticketSet.add(Ticket.Secret);
		ticketSet.add(Ticket.Underground);

		if(!(mrX.tickets.keySet().equals(ticketSet))){
			throw new IllegalArgumentException("Mr X missing tickets");
		}

		for(PlayerConfiguration detective : detectiveArray){
			detectiveTickets = detective.tickets.keySet();
			if (!(detectiveTickets.equals(ticketSet))){
				throw new IllegalArgumentException("Detective missing ticket");
			}
			if (!(detective.tickets.get(Ticket.Secret) == 0)){
				throw new IllegalArgumentException("Detective has secret move");
			}
			if (!(detective.tickets.get(Ticket.Double) == 0)){
				throw new IllegalArgumentException("Detective has double move");
			}
		}
	}

	//Checks that the start locations of the players are valid
	private void locationChecks(PlayerConfiguration mrX, ArrayList<PlayerConfiguration> detectiveArray){
		UniquenessChecker<Integer> unique = new UniquenessChecker<>();
		unique.addUniqueItem(mrX.location);

		for (PlayerConfiguration detective : detectiveArray){
			unique.addUniqueItem(detective.location);
		}
	}

	//Checks Mr X is black and all other players have unique colours
	private void colourChecks(PlayerConfiguration mrX, ArrayList<PlayerConfiguration> detectiveArray){
		if (!mrX.colour.isMrX()) throw new IllegalArgumentException("Mr X must have black colour");
		UniquenessChecker<Colour> unique = new UniquenessChecker<>();
		unique.addUniqueItem(mrX.colour);

		for (PlayerConfiguration detective : detectiveArray){
			unique.addUniqueItem(detective.colour);
		}
	}


	//Registers a single spectator and adds it to the list of spectators
	@Override
	public void registerSpectator(Spectator spectator) {
		if (spectators.contains(spectator)) throw new IllegalArgumentException("Spectator already in");
		spectators.add(requireNonNull(spectator));
	}

	//Removes a spectator from the list of spectators
	@Override
	public void unregisterSpectator(Spectator spectator) {
		Spectator temp = requireNonNull(spectator);
		if (spectators.contains(temp)) spectators.remove(temp);
		else throw new IllegalArgumentException("Illegal spectator");
	}

	//Gets the current list of spectators and returns an unmodifiableList
	@Override
	public Collection<Spectator> getSpectators() {
		return Collections.unmodifiableList(spectators);
	}

	//Notifies spectators of a round that has started
	public void notifySpectatorsOfRoundStarted(){
		for (Spectator spectator : spectators){
			spectator.onRoundStarted(this, currentRound);
		}
	}

	//Notifies spectators of a move that has been made
	public void notifySpectatorsOfMove(Move move){
		MoveTypeVisitor visitType = new MoveTypeVisitor();
		move.visit(visitType);
		for (Spectator spectator : spectators){
			switch (visitType.getType()){
				case 3: spectator.onMoveMade(this, (DoubleMove) move);
				break;
				case 2:	spectator.onMoveMade(this, (TicketMove) move);
				break;
				case 1: spectator.onMoveMade(this, (PassMove) move);
				break;
			}
		}
	}

	//Increments currentRound and notifies spectators of a new round and move
	public void incrementAndNotify(Move move){
		incrementRound();
		notifySpectatorsOfRoundStarted();
		notifySpectatorsOfMove(move);
	}


	//Checks the move is valid and performs the move.
	@Override
	public void accept(Move move){
		if (move == null) throw new NullPointerException("Null move");
		if (!possibleMoves.contains(move)) throw new IllegalArgumentException("Invalid Move");

		makeMovement(move);

		if (isGameOver()){
			for(Spectator spectator : spectators){
				spectator.onGameOver(this, getWinningPlayers());
			}
		}
		else if (players.indexOf(currentPlayer) == players.size() - 1){
			for (Spectator spectator : spectators){
				spectator.onRotationComplete(this);
			}
		}
		else{
			currentPlayer = players.get(players.indexOf(currentPlayer) + 1);
			moveRequest(currentPlayer);
		}
	}

	//Decides what type of move should be performed
	public void makeMovement(Move move){
		MoveTypeVisitor visitType = new MoveTypeVisitor();
		move.visit(visitType);
		switch (visitType.getType()){
			//Double
			case 3: doubleMovement((DoubleMove) move);
			break;
			//Ticket
			case 2: ticketMovement((TicketMove) move);
			break;
			//Pass
			case 1: passMovement((PassMove) move);
			break;
		}
	}

	//All movenement functions change player states, notify spectators and update the current round if needed
	//Calls methods for a double move
	public void doubleMovement(DoubleMove doubleMove){
		TicketMove newFirst, newSecond;
		DoubleMove newDouble;
		currentPlayer.removeTicket(Ticket.Double);
		currentPlayer.removeTicket(doubleMove.firstMove().ticket());
		currentPlayer.location(doubleMove.firstMove().destination());
		revealMrX();
		incrementRound();
		newFirst = new TicketMove(currentPlayer.colour(), doubleMove.firstMove().ticket(), mrXLastLocation);

		currentPlayer.removeTicket(doubleMove.secondMove().ticket());
		currentPlayer.location(doubleMove.secondMove().destination());
		revealMrX();
		newSecond = new TicketMove(currentPlayer.colour(), doubleMove.secondMove().ticket(), mrXLastLocation);
		newDouble = new DoubleMove(currentPlayer.colour(), newFirst, newSecond);
		currentRound = currentRound - 1;

		notifySpectatorsOfMove(newDouble);

		incrementAndNotify(newFirst);
		incrementAndNotify(newSecond);
	}

	//Calls methods for a ticket move
	public void ticketMovement(TicketMove move){
		currentPlayer.removeTicket(move.ticket());
		currentPlayer.location(move.destination());
		if (currentPlayer.isDetective()){
			mrXPlayer.addTicket(move.ticket());
			notifySpectatorsOfMove(move);
		}
		else{
			revealMrX();
			TicketMove newMove = new TicketMove(currentPlayer.colour(), move.ticket(), mrXLastLocation);
			incrementAndNotify(newMove);
		}
	}

	//Calls methods for a pass move
	public void passMovement(PassMove move){
		if (currentPlayer.isMrX()){
			revealMrX();
			incrementAndNotify(move);
		}
		else{
			notifySpectatorsOfMove(move);
		}
	}


	//Returns a set containing the valid moves that a player can make
	public Set<Move> validMoves(ScotlandYardPlayer player){
		Set<Move> validMove = new HashSet<>();
		Set<Edge<Integer,Transport>> allEdges = new HashSet<>();
		Boolean canMoveTo;

		allEdges.addAll(graph.getEdgesFrom(graph.getNode((Integer) player.location())));

		for(Edge<Integer,Transport> edge : allEdges){
			canMoveTo = checkIfCanMoveTo(player,edge);

			if (canMoveTo){
				addAllPossibleMovesFromOneEdge(player, edge, validMove);
			}
		}

		if (validMove.isEmpty()){
			validMove.add(new PassMove(player.colour()));
		}

		return validMove;
	}

	//Adds all possible moves from a valid edge
	public void addAllPossibleMovesFromOneEdge(ScotlandYardPlayer player, Edge<Integer,Transport> edge, Set<Move> validMove){
		TicketMove ticketToAdd;
		ScotlandYardPlayer manipulatedPlayer;
		Ticket usedTicket = Ticket.fromTransport(edge.data());

		ticketToAdd = new TicketMove(player.colour(), usedTicket, edge.destination().value());
		validMove.add(ticketToAdd);

		if ((player.isMrX()) & (player.hasTickets(Ticket.Double)) & (currentRound + 1 < rounds.size())){
			manipulatedPlayer = changePlayer(player, usedTicket);
			validMove.addAll(validDoubleMoves(manipulatedPlayer, ticketToAdd));
		}

		if ((player.isMrX()) & (player.hasTickets(Ticket.Secret))){
			ticketToAdd = new TicketMove(player.colour(), Ticket.Secret, edge.destination().value());
			validMove.add(ticketToAdd);

			if ((player.tickets().get(Ticket.Double) > 0) & (currentRound + 1 < rounds.size())){
				manipulatedPlayer = changePlayer(player, Ticket.Secret);
				validMove.addAll(validDoubleMoves(manipulatedPlayer, ticketToAdd));
			}
		}
	}

	//Makes a new player so that it has 1 less ticket of a theoretically used one
	public ScotlandYardPlayer changePlayer(ScotlandYardPlayer player, Ticket ticketToEdit){
		ScotlandYardPlayer change;
		Map<Ticket,Integer> manipulatedTickets = new HashMap<>(player.tickets());
		manipulatedTickets.put(ticketToEdit, manipulatedTickets.get(ticketToEdit) - 1);
		change = new ScotlandYardPlayer(player.player(), player.colour(), player.location(), manipulatedTickets);
		return change;
	}

	//Returns a set containing all valid double moves from a first move or the empty set
	public Set<Move> validDoubleMoves(ScotlandYardPlayer player, TicketMove firstMove){
		Set<Move> doubleMoves = new HashSet<>();
		int source = firstMove.destination();
		Set<Edge<Integer,Transport>> nextEdges = new HashSet<>();
		Boolean ableToMoveTo;

		nextEdges.addAll(graph.getEdgesFrom(graph.getNode((Integer) source)));
		for(Edge<Integer,Transport> nextEdge: nextEdges){
			ableToMoveTo = checkIfCanMoveTo(player, nextEdge);
			if (ableToMoveTo){
				addDoubleMove(player, nextEdge, firstMove, doubleMoves);
			}
		}

		return doubleMoves;
	}

	//Adds a normal, and if possible secret, double move
	public void addDoubleMove(ScotlandYardPlayer player, Edge<Integer, Transport> nextEdge, TicketMove firstMove, Set<Move> doubleMoves){
		TicketMove secondMove = new TicketMove(player.colour(), Ticket.fromTransport(nextEdge.data()), nextEdge.destination().value());
		DoubleMove doubleTicket = new DoubleMove(player.colour(), firstMove, secondMove);
		doubleMoves.add(doubleTicket);

		if ((player.isMrX()) & (player.hasTickets(Ticket.Secret))){
			secondMove = new TicketMove(player.colour(), Ticket.Secret, nextEdge.destination().value());
			doubleTicket = new DoubleMove(player.colour(), firstMove, secondMove);
			doubleMoves.add(doubleTicket);
		}
	}

	//Returns a boolean to check if a node can be moved to from a certain edge
	public Boolean checkIfCanMoveTo(ScotlandYardPlayer player, Edge<Integer,Transport> edge){
		Boolean can = true;

		for (ScotlandYardPlayer otherDetective : players){
			if ((otherDetective.location() == edge.destination().value()) & (otherDetective.isDetective())){
				can = false;
			}
		}

		Ticket ticket = Ticket.fromTransport(edge.data());
		if(!player.hasTickets(ticket)){
			can = false;
		}
		return can;
	}


	//The current player requests the move here
	public void moveRequest(ScotlandYardPlayer movingPlayer){
		possibleMoves = validMoves(movingPlayer);
		movingPlayer.player().makeMove(this, movingPlayer.location(), possibleMoves, this);
	}

	//Starts a new rotation
	@Override
	public void startRotate() {
		if (isGameOver()) throw new IllegalStateException("Game already over");
		currentPlayer = mrXPlayer;
		moveRequest(currentPlayer);
	}

	//Returns the value stored in rounds for the currentRound
	@Override
	public boolean isRevealRound() {
		return rounds.get(currentRound);
	}


	//Returns an unmodifiableSet containing all player colours that have won
	@Override
	public Set<Colour> getWinningPlayers() {
		Set<Colour> winningPlayers = new HashSet<Colour>();
		switch(winners){
			case 1: winningPlayers.add(mrXPlayer.colour());
			break;
			case 2:
			for (ScotlandYardPlayer detective : players){
				if(detective.isDetective()){
					winningPlayers.add(detective.colour());
				}
			}
			break;
		}
		return Collections.unmodifiableSet(winningPlayers);
	}

	//Checks if the game is over or not
	@Override
	public boolean isGameOver() {
		Boolean detectivesStuck = true;

		for (ScotlandYardPlayer detective : players){
			if (detective.isDetective()){
				if (detective.location() == mrXPlayer.location()){
					winners = 2;
					return true;
				}
				detectivesStuck = detectivesStuck & canPassOnly(detective);
			}
		}

		if (detectivesStuck){
			winners = 1;
			return true;
		}

		if ((canPassOnly(mrXPlayer)) & (lastPlayer())){
			winners = 2;
			return true;
		}

		if ((!moreRounds()) & (lastPlayer())){
			winners = 1;
			return true;
		}

		return false;
	}


	//Increments the round if the currentPlayer is Mr X
	public void incrementRound(){
		if (currentPlayer.isMrX()){
			currentRound = currentRound + 1;
		}
	}

	//Updates last location of Mr X if it is a reveal round
	public void revealMrX(){
		if (isRevealRound()) mrXLastLocation = mrXPlayer.location();
	}

	//Returns a boolean if there are any more rounds left
	public Boolean moreRounds(){
		return !(currentRound == rounds.size());
	}

	//Checks if the currentPlayer is the last player in the list
	public Boolean lastPlayer(){
		return (players.indexOf(currentPlayer) == players.size() - 1);
	}

	//Checks if there are only pass moves for a player
	public Boolean canPassOnly(ScotlandYardPlayer player){
		Set<Move> passMoveOnly = new HashSet<>();
		passMoveOnly.add(new PassMove(player.colour()));
		return validMoves(player).equals(passMoveOnly);
	}


	//Returns the location of a specific player. If the player is Mr X, returns his last location
	@Override
	public int getPlayerLocation(Colour colour) {
		int location = 0;
		for(ScotlandYardPlayer player: players){
			if (player.colour() == colour){
				if (player.isMrX()){
					location = mrXLastLocation;
				}
				else location = player.location();
			}
		}
		return location;
	}

	//Returns the number of tickets that a player has
	@Override
	public int getPlayerTickets(Colour colour, Ticket ticket) {
		int tickets = 0;
		for(ScotlandYardPlayer player : players){
			if(player.colour() == colour){
				tickets = player.tickets().get(ticket);
			}
		}
		return tickets;
	}

	//Returns an unmodifiableList of the colours of all players
	@Override
	public List<Colour> getPlayers() {
		List<Colour> colours = new ArrayList<>();
		for (ScotlandYardPlayer player : players){
			colours.add(player.colour());
		}
		return Collections.unmodifiableList(colours);
	}

	//Returns the current player colour
	@Override
	public Colour getCurrentPlayer() {
		return currentPlayer.colour();
	}

	//Returns the number of the current round
	@Override
	public int getCurrentRound() {
		return currentRound;
	}

	//Returns an unmodifiableList containing rounds
	@Override
	public List<Boolean> getRounds() {
		return Collections.unmodifiableList(rounds);
	}

	//Returns an ImmutableGraph containg graph
	@Override
	public Graph<Integer, Transport> getGraph() {
		return new ImmutableGraph(this.graph);
	}

}
